use app_cryptography::jwt::{Algorithm, Claims, RedisInfo, generate_token};
use app_error::AppError;
use app_redis::Redis;
use app_state::AppState;
use askama::Template;
use axum::{
    extract::{Query, State},
    response::{Html, Redirect},
};
use chrono::{Duration, Utc};
use rand::Rng;
use serde::Deserialize;
use std::sync::Arc;
use tracing::*;

// #[get("/google/auth")]
pub async fn get_google_auth(State(state): State<Arc<AppState>>) -> Result<Redirect, AppError> {
    let config = state.config.clone();
    let auth_url = format!(
        "{}&client_id={}&redirect_uri={}",
        &config.google_auth_url, &config.google_client_id, &config.google_redirect
    );
    info!("Redirecting to {}", &auth_url);
    Ok(Redirect::to(&auth_url))
}

/// Extract the query parameter (`code`) from Google’s callback URL.
/// (In a production app, you should also verify a `state` parameter.)
#[derive(Deserialize)]
pub struct AuthQuery {
    pub code: String,
}

/// Represents the JSON response from Google’s token endpoint.
#[derive(Deserialize)]
struct TokenResponse {
    access_token: String,
    // Other fields (id_token, expires_in, etc.) can be added as needed.
}

#[derive(Deserialize)]
struct UserInfo {
    _sub: Option<String>, // Unique identifier
    name: Option<String>,
    _given_name: Option<String>,
    _family_name: Option<String>,
    _picture: Option<String>, // Profile image URL
    email: Option<String>,
    _email_verified: Option<bool>, // Whether email is verified
    _locale: Option<String>,
}

// #[get("/google/callback")]
pub async fn get_google_callback(
    // req: HttpRequest,
    State(state): State<Arc<AppState>>,
    Query(query): Query<AuthQuery>,
) -> Result<Redirect, AppError> {
    let config = state.config.clone();
    let redis = state.redis.clone();
    let jwt_access_key = config.jwt_access_key.clone();
    let jwt_access_session_min = config.jwt_access_session_minutes;
    let jwt_refresh_key = config.jwt_refresh_key.clone();
    let jwt_refresh_session_day = config.jwt_refresh_session_days;
    // GOOGLE USER PROCEDURE
    // Code generated by google
    let code = query.code.clone();
    // HTTP Client
    let client = reqwest::Client::new();
    // --- Step 1: Exchange the code for an access token ---
    let params = [
        ("code", code.as_str()),
        ("client_id", &config.google_client_id),
        ("client_secret", &config.google_client_secret),
        ("redirect_uri", &config.google_redirect),
        ("grant_type", "authorization_code"),
    ];

    let token_resp = client
        .post(&config.google_token_url)
        .form(&params)
        .send()
        .await;

    let token_resp = match token_resp {
        Ok(resp) => resp,
        Err(err) => {
            error!("Error sending token request: {}", err);
            return Err(AppError::internal("Token request failed"));
        }
    };

    if !token_resp.status().is_success() {
        let text = token_resp.text().await.unwrap_or_default();
        error!("Token endpoint returned error: {}", text);
        return Err(AppError::internal("Token request failed"));
    }

    let token: TokenResponse = match token_resp.json().await {
        Ok(t) => t,
        Err(err) => {
            error!("Error parsing token response: {}", err);
            return Err(AppError::internal("Failed to parse token response"));
        }
    };

    // --- Step 2: Use the access token to fetch user info ---
    let userinfo_resp = client
        .get(&config.google_userinfo_url)
        .bearer_auth(&token.access_token)
        .send()
        .await;

    let userinfo_resp = match userinfo_resp {
        Ok(resp) => resp,
        Err(err) => {
            error!("Error sending userinfo request: {}", err);
            return Err(AppError::internal("Userinfo request failed"));
        }
    };

    if !userinfo_resp.status().is_success() {
        let text = userinfo_resp.text().await.unwrap_or_default();
        error!("Userinfo endpoint returned error: {}", text);
        return Err(AppError::internal("Userinfo request failed"));
    }

    // GOOGLE USER
    let user_info: UserInfo = match userinfo_resp.json().await {
        Ok(info) => info,
        Err(err) => {
            error!("Error parsing userinfo response: {}", err);
            return Err(AppError::internal("Failed to parse userinfo"));
        }
    };
    let email = match &user_info.email {
        None => "Google email is not defined".into(),
        Some(email) => email.clone(),
    };
    let name = match &user_info.name {
        None => "Google name is not defined".into(),
        Some(name) => name.clone(),
    };

    // OUR APP TOKEN GENERATION

    // --- Step 3: Generate internal tokens and regular auth ---
    // Access Token
    let session: u64 = {
        let mut rng = rand::thread_rng();
        rng.r#gen()
    };
    let iat = Utc::now().timestamp();
    let exp = (Utc::now() + Duration::minutes(jwt_access_session_min)).timestamp();
    let access_claim = Claims {
        iat,
        exp,
        id: "-1".to_owned(),
        name: name.clone(),
        email: email.clone(),
        session,
        source: "google".into(),
    };

    // Refresh Token
    let exp = (Utc::now() + Duration::days(jwt_refresh_session_day)).timestamp();
    let refresh_claim = Claims {
        iat,
        exp,
        id: "-1".to_owned(),
        name: name.clone(),
        email: email.clone(),
        session,
        source: "google".into(),
    };

    // Generate Tokens
    let access_token = generate_token(Algorithm::HS256, &jwt_access_key, &access_claim)?;
    let refresh_token = generate_token(Algorithm::HS256, &jwt_refresh_key, &refresh_claim)?;

    // Saving Refresh Token in Redis
    let redis_key = format!("{}:{}", &email, &session);
    let redis_info = RedisInfo {
        id: "-1".to_owned(),
        name: name.clone(),
        email: email.clone(),
        session,
        token: refresh_token.clone(),
        source: "google".into(),
    };
    let redis_info_str = serde_json::to_string(&redis_info)?;
    let _ = Redis::set(&redis, &redis_key, &redis_info_str).await?;

    let url = format!("/google/token?token={} {}", access_token, refresh_token);

    // Redirect to Main Page
    Ok(Redirect::to(&url))
}

#[derive(Template)]
#[template(path = "token.html")]
struct GoogleTokenPage;

// #[get("/google/token")]
pub async fn page_google_token() -> Result<Html<String>, AppError> {
    let page = GoogleTokenPage {};
    Ok(Html(page.render()?))
}
